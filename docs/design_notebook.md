# Saturday, 22 May 2021
- How to handle opaque modules that have variable length internal data?
    - E.g. Circular buffer with variable size
    - Malloc / Malloc + zero-length array (I guess has the advantage of being an array instead of a pointer)
    - Memory pool / Memory pool + ZLA
        - Can be internal or external. For external, can be either specific (e.g. myStruct mem_pool[MAX_STRUCTS] or int32_t mem_pool[MAX_NUM_INT32]) or general (i.e. a replacement for malloc)
        - If external, module requires either (1) a pointer to data or (2) an API to create/return data
        - Internal only really feasible if there is a small, set number of types to be managed
    - Remove the internal data. Give the module a pointer to a piece of external data or a delegate to create/return data as needed.
    - Using linked-list (vice array) mitigates the problem of fragmentation
    - Ideas below are ill-advised, since they still require the opaque struct to make known it's size/alignment, which defeats some of the purpose of an opaque struct (the size/alignment of any updated opaque structs have to remain unchanged or risk breaking clients' code)
        - All of the above are still dynamic, meaning that they still allow for the possibility that a system might run out of memory. How could you define, at compile-time and across many compilation units, a desired size for the objects of another module? Export object size?
        - Could maybe use VLA, giving pointer to array to module, provided the caller never left scope (I think this only works for preemptive, infinite loop tasks)
        - Use alloca + a "get_size" function to allocate memory in the caller's frame
            - Would require changing the API slightly, to allow "init" without "create" 
    - https://stackoverflow.com/questions/4440476/static-allocation-of-opaque-data-types
    - https://stackoverflow.com/questions/22800594/c-best-practice-for-using-stack-memory-for-incomplete-structs
- How to handle modules that operate on variable data types?
    - E.g. Circular buffer for variable data types
    - Functions take a `void *` and `size_t` and just push bytes around
    - Use macros
        - https://www.oracle.com/solaris/technologies/c-type.html
        - https://www.davidespataro.it/kernel-linux-list-efficient-generic-linked-list/
    - Make a union/ADT
        - Not scalable; only really works if there are a very small number of specific data types
        - Or maybe not? "Fun with Unions" used a few primitives and an array of unions to create ~59k data types
        - ADT would give some measure of type-checking, though
    - Var args? --> Functionally the same as `void *`, though perhaps a bit more complicated.
    - __Generic? That's part of the C standard.
    - Serialization
    - `void *` to container (like Linux LL but using a pointer to container, rather than the `container_of` macro)
    - How to account for different function signatures (e.g. `cb_put(cb, INT)`, `cb_put(cb, STRUCT)`, etc)
    - `#define TYPE struct` / `typedef struct TYPE` (for single-instance module)
- Other factors to consider
    - Macros vs functions
    - Static vs dynamic memory allocation
        - (1) Malloc
        - (2) Internal memory pool, block size = 1
            - e.g. for structs with constant size or for linked list nodes
        - (3) Internal memory pool, block size >= 1
            - e.g. for variable length arrays
        - (4) External memory pool, module gets pointer to data
            - e.g. for arrays
        - (5) External memory pool, module uses API/delegate to create/return data
            - Could be specific to a data type or more general (i.e. reimplementation of malloc)
            - If specific to a data type, block size could be = 1 or >= 1
        - Only (4) allows for compile-time verification of max memory usage (i.e. is not dynamic)
        - Only (2), (4) and (5) (for block size = 1) avoid fragmentation
        - For (3) and (5) (for block size >= 1), it seems *possible* to create a "simple malloc" by creating an array of bytes and reserving them based on the number of bytes required. This would allow for arbitrary data types to be used with a module. *However*,
            - Modules can **only** move data to/from memory using byte-transfers (i.e. memcpy)
            - Still suffers from possible fragmentation and any effort to mitigate that issue complicates the code sufficiently that a whole new module should be created to handle what is quickly becoming a reimplementation of malloc.
            - Like a very crude/simple form of serialization.
            - Behaves very different from normal variables. Instead of reading/writing memory directly, we have to work through memcpy.
            - https://blog.regehr.org/archives/959
        - Other considerations for variable data types?
    - Single-instance vs multiple-instance module
    - Which implementations offer type-checking?

# Sunday, 23 May 2021
- Improve tlist by...
    - Using static memory
        - For each module that uses tlist to create a linked list, declare an array of structs for the data being used (plus an "in_use" flag); basically a memory pool
        - Pass in the address of that array to any macros that might create a new node
        - Change "malloc" to finding an array element not in use
    - Using functions
        - ??
    - How is tlist used by other modules? How are linked lists exported?
        - It probably isn't. Module in question should just expose a "put" method that, internally, uses tlist.
- Improve circular buffer by...
    - Using arbitrary data types
        - Add size of buffer elements to constructor
        - Allocate size * num for buffer
        - Change put and get to take a void *. Put copies size bytes from void * to buffer. Get copies size bytes from buffer to void *.
    - Using static memory
        - Declare array of data prior to construction. Pass in to constructor a `void *` pointer to the array and `size_t` of the data.
